import createGraph, { type Node, type Link } from "ngraph.graph";
import FS from "node:fs/promises";
import Path from "node:path";
import { $ } from "bun";
import { load } from "cheerio";
import type { Element } from "domhandler";
import matter from "gray-matter";
import bcdData from "@mdn/browser-compat-data" with { type: "json" };
import { getBCD } from "./utils.js";
import {
  CONTENT_SOURCE_ROOT,
  BUILT_CONTENT_ROOT,
  readConfig,
  configHas,
} from "./config.js";
import { checkContent, postCheckContent } from "./check-content.js";

const nonContentPaths = [
  "/en-US/",
  "/en-US/about",
  "/en-US/curriculum/",
  "/en-US/observatory",
  "/en-US/observatory/",
  "/en-US/play",
  "/en-US/plus",
];

const allowedNoSidebar = new Map(
  (await readConfig("allowed-no-sidebar.txt")).map((x) => [x, false]),
);

function globToRegex(str: string) {
  return new RegExp(
    `^${str
      .split(/(\*\*?)/)
      .map((part, i) =>
        i % 2 === 0
          ? part.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
          : part === "*"
            ? "[^/]+"
            : part === "**"
              ? ".+"
              : "",
      )
      .join("")}$`,
  );
}

const allowedNotInSidebar = new Map(
  (await readConfig("allowed-not-in-sidebar.txt")).map((x) => [
    globToRegex(x),
    false,
  ]),
);

const sidebarExternalLinks = [
  "https://blog.mozilla.org/addons",
  "https://discourse.mozilla.org/c/add-ons",
  "https://chat.mozilla.org/#/room/%23addons:mozilla.org",
  "https://firefox-source-docs.mozilla.org",
  "https://extensionworkshop.com/documentation/themes",
  "https://extensionworkshop.com/documentation/develop",
  "https://extensionworkshop.com/documentation/publish",
  "https://extensionworkshop.com/documentation/manage",
  "https://extensionworkshop.com/documentation/enterprise",
  "https://stackoverflow.com/questions/tagged/firefox-addon",
  "https://mozdevs.github.io/html5-games-workshop/en/guides/platformer/start-here",
];

function isAllowedSelfLink(a: Element, part: any) {
  // This page has an example attribution of itself
  if (
    a.attribs.href ===
    "/en-US/docs/MDN/Writing_guidelines/Attrib_copyright_license"
  ) {
    return true;
  }
  // But: some self-links are generated by macros and it's not worth
  // fixing them
  let cur = a.parentNode;
  while (cur && cur.type === "tag" && cur.tagName !== "body") {
    if (
      cur.tagName === "figure" &&
      cur.attribs.class === "table-container" &&
      cur.parentNode?.type === "tag" &&
      cur.parentNode.tagName === "body" &&
      ["formal_definition", "usage_context"].includes(part.value.id)
    ) {
      // This is a formal definition table; the link may be
      // used for other purposes
      return true;
    }
    if (cur.tagName === "dd" && cur.attribs.class === "landingPageList") {
      // This is a subpage list; the link is transcluded from
      // another page
      return true;
    }
    if (
      cur.tagName === "div" &&
      cur.attribs.class === "notecard note" &&
      load(cur).text() ===
        "Note: This feature is only available in Dedicated Web Workers."
    ) {
      // The DedicatedWorkerGlobalScope page has this peculiar case where
      // the template links to itself
      return true;
    }
    cur = cur.parentNode;
  }
  return false;
}

async function* listdir(dir: string): AsyncGenerator<string> {
  for await (const dirent of await FS.readdir(dir, { withFileTypes: true })) {
    if (dirent.isDirectory()) {
      yield* listdir(`${dir}/${dirent.name}`);
    } else {
      yield `${dir}/${dirent.name}`;
    }
  }
}

export default async function createContentGraph() {
  const graph = createGraph();

  for await (const file of listdir(
    Path.join(BUILT_CONTENT_ROOT, "en-us/docs"),
  )) {
    if (!file.endsWith(".json")) continue;
    if (file.includes("en-us/docs/mdn/kitchensink")) continue;
    const content = await Bun.file(file).json();
    if (file.endsWith("metadata.json")) {
      const existingNode = graph.getNode(content.mdn_url);
      if (existingNode) {
        existingNode.data.metadata = content;
      } else {
        graph.addNode(content.mdn_url, { metadata: content });
      }
    } else if (file.endsWith("index.json")) {
      const existingNode = graph.getNode(content.url);
      if (existingNode) {
        // TODO: currently has too many flaws (mostly redirects)
        // existingNode.data.flaws = content.doc.flaws;
        existingNode.data.flaws = {};
        existingNode.data.content = content.doc.body;
        existingNode.data.sidebarHTML = content.doc.sidebarHTML;
        existingNode.data.live_samples = content.doc.live_samples;
      } else {
        graph.addNode(content.url, {
          content: content.doc.body,
          sidebarHTML: content.doc.sidebarHTML,
          live_samples: content.doc.live_samples,
        });
      }
    }
  }

  const promises: Promise<void>[] = [];

  graph.forEachNode((node) => {
    const sourcePath = Path.join(
      CONTENT_SOURCE_ROOT,
      node.data.metadata.source.folder,
      "index.md",
    );
    promises.push(
      FS.readFile(sourcePath, "utf8")
        .then((source) => {
          const { data } = matter(source);
          node.data.metadata.pageType = data["page-type"];
          if (!node.data.metadata.pageType) {
            report(node, "Missing page type");
          }
          node.data.metadata.frontMatter = data;
          if (data["browser-compat"]) {
            data["browser-compat"] = Array.isArray(data["browser-compat"])
              ? data["browser-compat"]
              : [data["browser-compat"]];
          }
          if (data["spec-urls"]) {
            data["spec-urls"] = Array.isArray(data["spec-urls"])
              ? data["spec-urls"]
              : [data["spec-urls"]];
          }
          if (
            (data["browser-compat"] && !node.data.metadata.browserCompat) ||
            (!data["browser-compat"] && node.data.metadata.browserCompat)
          ) {
            console.warn(
              "Mismatched browser compat",
              node.id,
              data["browser-compat"],
              node.data.metadata.browserCompat,
            );
          } else if (data["browser-compat"]) {
            for (let i = 0; i < data["browser-compat"].length; i++) {
              if (
                data["browser-compat"][i] !==
                node.data.metadata.browserCompat[i]
              ) {
                console.warn(
                  "Mismatched browser compat",
                  node.id,
                  data["browser-compat"],
                  node.data.metadata.browserCompat,
                );
                break;
              }
            }
          }
        })
        .catch((e) => {
          console.error("Error reading file", sourcePath, e);
        }),
    );
  });

  await Promise.all(promises);

  const warnings: { [nodeId: string]: { message: string; data: any }[] } = {};

  function report(node: Node, message: string, ...args: any[]) {
    (warnings[node.data.metadata.source.folder] ??= []).push({
      message,
      data: args,
    });
  }

  const dtIdToLink = new Map<
    string,
    Map<string, { href: string; pageExists: boolean }>
  >();

  const pageToCodes = new Map<
    string,
    { language: string; content: string }[]
  >();

  const filePathToNodeId = new Map<string, string>();

  graph.forEachNode((node) => {
    filePathToNodeId.set(node.data.metadata.source.folder, node.id);
    if (!node.data || !node.data.content) {
      console.error(node.id, "has no content");
      return;
    }
    const content = node.data.content;
    const linkTargets: string[] = [];
    const imgs: string[] = [];
    const ids: string[] = [];
    const codes: { language: string | null; content: string }[] = [];
    pageToCodes.set(node.id, codes);
    let hasBCDTable = false;
    for (const part of content) {
      // TODO Yari does this case folding but it should just output lowercase IDs
      // in the build output
      if (part.value.id) ids.push(part.value.id.toLowerCase());
      switch (part.type) {
        case "specifications":
          if (node.data.specifications)
            report(node, "Duplicate specifications");
          node.data.specifications = part.value.specifications;
          continue;
        case "browser_compatibility":
          // We use metadata.browserCompat instead of part.value.query.
          // The only way for part.value.query to not be included in
          // metadata.browserCompat is by using the argument of the {{Compat}}
          // macro, but that is reported as a flaw.
          hasBCDTable = true;
          continue;
        case "prose":
          break;
        default:
          console.error(node.id, "Unknown part type", part.type);
          continue;
      }
      const partContent = part.value.content;
      const $ = load(partContent);
      checkContent(partContent, $, report.bind(null, node), { slug: node.id });
      $("[id]").each((i, el) => {
        const id = $(el).attr("id")!;
        if (ids.includes(id)) report(node, "Duplicate ID", id);
        ids.push(id);
      });
      $("dt").each((i, dt) => {
        // The ID is injected by Yari
        const id = $(dt).attr("id")!;
        const link = $(dt)
          .find("a")
          .filter((i, a) => !!a.attribs.href && a.attribs.href !== `#${id}`);
        if (link.length === 1) {
          const href = link[0].attribs.href;
          // Missing href is already reported above
          if (!dtIdToLink.has(node.id)) dtIdToLink.set(node.id, new Map());
          const pageExists =
            graph.getNode(
              new URL(href, "https://developer.mozilla.org").pathname,
            ) !== undefined;
          dtIdToLink.get(node.id)!.set(id, { href, pageExists });
        }
      });
      $("img").each((i, img) => {
        imgs.push($(img).attr("src")!);
      });
      // Exclude links automatically generated by inheritance diagrams
      // and the formal syntax section, because they tend to be broken and/or
      // self-linking but cannot be fixed in content
      $("a:not(svg a, pre.css-formal-syntax a)").each((i, a) => {
        const href = $(a).attr("href") || $(a).attr("data-href");
        if (!href) {
          report(node, "Missing href", $(a).text());
          return;
        }
        if (
          $(a).parent().attr("id") === href.slice(1) ||
          href.startsWith("#livesample_fullscreen=")
        ) {
          // This link is autogenerated; we should still do the check above but
          // don't treat it as a real link target
          return;
        }
        const url = new URL(href, "https://developer.mozilla.org");
        // Self-links are not added as real link targets
        if (node.id === url.pathname && !href.startsWith("#")) {
          if (!isAllowedSelfLink(a, part)) {
            report(node, "Self link", href);
          }
          return;
        }
        linkTargets.push(href);
      });
      let selector = "pre:not(.css-formal-syntax)";
      if (
        part.value.id === "syntax" &&
        ![
          "guide",
          "html-attribute",
          "mdn-writing-guide",
          "webextension-manifest-key",
          "webdriver-command",
        ].includes(node.data.metadata.pageType)
      ) {
        const syntaxSelector = `body > div.code-example:${node.data.metadata.pageType === "web-api-event" ? "nth-child(2)" : "first-child"} pre, body > pre:first-child`;
        const syntaxCode = $(syntaxSelector);
        selector = `pre:not(${syntaxSelector})`;
        if (!syntaxCode.length) {
          report(node, "Missing syntax code block");
        }
      }
      $(selector).each((i, pre) => {
        const code = $(pre).text();
        const language = $(pre)
          .attr("class")
          ?.match(new RegExp(/brush: ([\w-]+)(?: |$)/))?.[1];
        if (!language) {
          report(node, "Invalid code block language", $(pre).attr("class"));
        }
        codes.push({ language: language ?? "plain", content: code });
      });
    }
    if (
      (node.data.metadata.frontMatter["spec-urls"]?.length ||
        (node.data.metadata.browserCompat
          ?.map((k: string) => getBCD(bcdData, k)?.__compat?.spec_url)
          .filter(Boolean).length &&
          !["guide", "learn-module-chapter"].includes(
            node.data.metadata.pageType,
          ))) &&
      !node.data.specifications
    ) {
      report(node, "Missing specifications macro");
    }
    if (
      node.data.metadata.browserCompat &&
      !hasBCDTable &&
      node.id !==
        "/en-US/docs/MDN/Writing_guidelines/Page_structures/Specification_tables"
    ) {
      const notExist = node.data.metadata.browserCompat.some(
        (k: string) => !getBCD(bcdData, k),
      );
      report(node, "Missing BCD table", ...(notExist ? ["(key invalid)"] : []));
    }
    node.data.links = linkTargets;
    node.data.imgs = imgs;
    node.data.ids = ids;
    delete node.data.content;
  });

  postCheckContent();

  graph.forEachNode((node) => {
    for (const linkTarget of node.data.links) {
      // Internal image links cannot be resolved by the graph so report them separately
      if (
        /\.(?:jpe?g|png|svg|gif)$/.test(linkTarget) &&
        !(linkTarget.startsWith("https:") || linkTarget.startsWith("http:"))
      ) {
        report(node, "Image link", linkTarget);
      } else if (linkTarget.startsWith("/en-US/")) {
        if (
          nonContentPaths.includes(linkTarget) ||
          linkTarget.startsWith("/en-US/blog/")
        )
          continue;
        const url = new URL(linkTarget, "https://developer.mozilla.org");
        const targetNode = graph.getNode(url.pathname);
        if (!targetNode) {
          report(node, "Broken link", url.pathname);
          continue;
        }
        if (url.hash && !url.hash.startsWith("#:~:")) {
          if (
            !targetNode.data.ids.includes(decodeURIComponent(url.hash.slice(1)))
          ) {
            report(node, "Broken anchor", url.pathname, url.hash);
          } else {
            // The target may have no DT links
            const targetDtLink = dtIdToLink
              .get(url.pathname)
              ?.get(url.hash.slice(1));
            // Only report if the link to be replaced with is a subpage
            if (targetDtLink && targetDtLink.href.startsWith(url.pathname)) {
              report(
                node,
                "Replace DT link with real target",
                linkTarget,
                targetDtLink.href,
                ...[targetDtLink.pageExists ? [] : ["(page does not exist)"]],
              );
            }
          }
        }
        graph.addLink(node.id, url.pathname);
      } else if (linkTarget.startsWith("#")) {
        if (!node.data.ids.includes(decodeURIComponent(linkTarget.slice(1)))) {
          if (linkTarget === "#browser_compatibility") {
            report(node, "Broken browser compat anchor");
          } else if (!linkTarget.startsWith("#:~:")) {
            report(node, "Broken anchor", linkTarget);
          }
        } else {
          const targetDtLink = dtIdToLink
            .get(node.id)
            ?.get(linkTarget.slice(1));
          if (targetDtLink && targetDtLink.href.startsWith(node.id)) {
            report(
              node,
              "Replace DT link with real target",
              linkTarget,
              targetDtLink.href,
              ...[targetDtLink.pageExists ? [] : ["(page does not exist)"]],
            );
          }
        }
      } else if (
        !linkTarget.startsWith("http") ||
        (linkTarget.includes("//localhost") &&
          !linkTarget.includes("_sample_."))
      ) {
        if (
          linkTarget.startsWith("mailto:") ||
          linkTarget.startsWith("news:") ||
          linkTarget.startsWith("irc:") ||
          ["/", "/discord"].includes(linkTarget)
        ) {
          continue;
        } else {
          report(node, "Bad href", linkTarget);
        }
      }
    }
  });

  const allImgs = new Map<string, boolean>();
  for await (const file of listdir(Path.join(CONTENT_SOURCE_ROOT, "en-us"))) {
    // Hack to exclude files at the root of the content source
    if (
      !Path.relative(file, Path.join(CONTENT_SOURCE_ROOT, "en-us")).includes(
        "/",
      )
    )
      continue;
    if (file.includes("en-us/mdn/kitchensink")) continue;
    if (["index.md", ".DS_Store"].includes(Path.basename(file))) continue;
    const folder = Path.dirname(Path.relative(CONTENT_SOURCE_ROOT, file));
    const nodeId = filePathToNodeId.get(folder);
    if (!nodeId) {
      report(
        graph.getNode("/en-US/docs/Web")!,
        "Asset without content page",
        Path.relative(CONTENT_SOURCE_ROOT, file),
      );
      continue;
    }
    if (
      [".png", ".jpg", ".jpeg", ".gif", ".svg"].includes(Path.extname(file))
    ) {
      allImgs.set(`${nodeId}/${Path.basename(file)}`, false);
    } else {
      report(
        graph.getNode(nodeId)!,
        "Unexpected asset file",
        Path.basename(file),
      );
    }
  }
  graph.forEachNode((node) => {
    for (const img of node.data.imgs) {
      if (img.startsWith("https:") || img.startsWith("http:")) {
        if (!img.startsWith("https://mdn.github.io/shared-assets/"))
          report(node, "External image", img);
      } else {
        if (!allImgs.has(img)) {
          report(node, "Missing image", img);
        } else {
          allImgs.set(img, true);
        }
      }
    }
    for (const liveSample of node.data.live_samples) {
      const { css = "", js = "", html = "" } = liveSample;
      const jsSrcReferences = js.matchAll(/\.src = ["']([^"']+)["']/g);
      const jsHrefReferences = js.matchAll(/\.href = ["']([^"']+)["']/g);
      const htmlSrcReferences = html.matchAll(/src=["']([^"']+)["']/g);
      const htmlHrefReferences = html.matchAll(/href=["']([^"']+)["']/g);
      const cssUrlReferences = css.matchAll(/url\(["']?([^"')]+)["']?\)/g);
      for (const match of [...jsSrcReferences, ...jsHrefReferences, ...htmlSrcReferences, ...htmlHrefReferences, ...cssUrlReferences]) {
        const src = match[1];
        if (!src.startsWith("https:") && !src.startsWith("http:") && !src.startsWith("/shared-assets/") && src !== "#") {
          const resolvedSrc = new URL(src, `https://developer.mozilla.org${node.id}/`).pathname;
          if ([".png", ".jpg", ".jpeg", ".gif", ".svg"].includes(Path.extname(resolvedSrc))) {
            if (!allImgs.has(resolvedSrc)) {
              report(node, "Missing image", src);
            } else {
              allImgs.set(resolvedSrc, true);
            }
          }
        }
      }
    }
    delete node.data.live_samples;
  });

  for (const [img, used] of allImgs) {
    if (!used) {
      report(
        graph.getNode(Path.dirname(img))!,
        "Unused image",
        Path.basename(img),
      );
    }
  }

  const nodes: Node[] = [];

  graph.forEachNode((node) => {
    nodes.push(node);
  });

  const links: Link[] = [];

  graph.forEachLink((link) => {
    links.push(link);
  });

  const unreachableViaPage = new Set<Node>(nodes);
  const visited = new Set<Node>();

  const queue = [graph.getNode("/en-US/docs/Web")];
  while (queue.length) {
    const node = queue.shift()!;
    graph.forEachLinkedNode(
      node.id,
      (linkedNode) => {
        if (!visited.has(linkedNode)) {
          visited.add(linkedNode);
          unreachableViaPage.delete(linkedNode);
          queue.push(linkedNode);
        }
      },
      true,
    );
  }

  graph.forEachNode((node) => {
    const id = node.id;
    let parentId = node.id.replace(/\/[^/]+$/, "");
    const parentOverride = {
      "/en-US/docs/Glossary": null,
      "/en-US/docs/Web/CSS": null,
      "/en-US/docs": "/en-US/docs/Web",
    };
    parentId = parentId in parentOverride ? parentOverride[parentId] : parentId;
    if (
      parentId === "/en-US/docs/Web/API" &&
      node.data.metadata.pageType === "webgl-extension"
    ) {
      return;
    }
    if (parentId && parentId !== id && !graph.hasLink(parentId, id)) {
      report(graph.getNode(parentId), "No link to child page", node.id);
    }
  });

  const processedSidebars = new Map<
    string,
    {
      id: number;
      links: { href: string | undefined; text: string }[];
      includedPages: string[];
    }
  >();
  const pageToSidebarId = new Map<string, number>();
  let sidebarId = 0;

  for (const node of nodes) {
    const { sidebarHTML } = node.data;
    delete node.data.sidebarHTML;
    if (!sidebarHTML) {
      if (!configHas(allowedNoSidebar, node.id))
        report(node, "Missing sidebar");
      continue;
    }
    const normalizedHTML = sidebarHTML
      .replace(/ open(="[^"]*")?| aria-current="page"|<\/?em>/g, "")
      .replace(
        `<code>${node.data.metadata.short_title}</code> `,
        () =>
          `<a href="${node.id}"><code>${node.data.metadata.short_title}</code></a>`,
      );
    if (processedSidebars.has(normalizedHTML)) {
      processedSidebars.get(normalizedHTML)!.includedPages.push(node.id);
      pageToSidebarId.set(node.id, processedSidebars.get(normalizedHTML)!.id);
      continue;
    }
    const $ = load(normalizedHTML);
    const links = $("a")
      .map((i, a) => ({
        href: ($(a).attr("href") || $(a).attr("data-href"))?.replace(/\/$/, ""),
        text: $(a).text(),
      }))
      .get();
    processedSidebars.set(normalizedHTML, {
      id: sidebarId++,
      links,
      includedPages: [node.id],
    });
    pageToSidebarId.set(node.id, processedSidebars.get(normalizedHTML)!.id);
  }

  for (const [slug, used] of allowedNoSidebar) {
    if (!used) console.warn(slug, "now has a sidebar");
  }

  const sidebarIds = new Map<
    number,
    {
      links: { href: string | undefined; text: string }[];
      includedPages: string[];
    }
  >();
  for (const { id, links, includedPages } of processedSidebars.values()) {
    sidebarIds.set(id, { links, includedPages });
  }

  for (const { links, includedPages } of sidebarIds.values()) {
    for (const { href, text } of links) {
      if (href && sidebarExternalLinks.includes(href)) {
        continue;
      }
      if (href && href.startsWith("/en-US/")) {
        const url = new URL(href, "https://developer.mozilla.org");
        const targetNode = graph.getNode(url.pathname);
        if (
          (!targetNode &&
            !nonContentPaths.includes(url.pathname) &&
            !url.pathname.startsWith("/en-US/blog/")) ||
          (url.hash &&
            targetNode &&
            !targetNode.data.ids.includes(url.hash.slice(1)))
        ) {
          report(
            graph.getNode(includedPages[0]!)!,
            "Broken sidebar link",
            text,
            href,
          );
        }
      } else {
        report(
          graph.getNode(includedPages[0]!)!,
          "Bad sidebar link",
          text,
          href,
        );
      }
    }
  }

  for (const node of nodes) {
    const sidebar = sidebarIds.get(pageToSidebarId.get(node.id)!);
    if (!sidebar) continue;
    if (!sidebar.links.some(({ href }) => href === node.id)) {
      const isAllowed = [...allowedNotInSidebar.keys()].find((regex) =>
        regex.test(node.id),
      );
      if (!isAllowed) {
        report(node, "Unreachable via sidebar");
      } else {
        allowedNotInSidebar.set(isAllowed, true);
      }
    }
  }
  for (const [regex, used] of allowedNotInSidebar) {
    if (!used) console.warn(regex, "is now included in the sidebar");
  }
  for (const node of unreachableViaPage) report(node, "Unreachable via page");

  for (const node of nodes) {
    node.data.metadata = Object.fromEntries(
      [
        "title",
        "pageType",
        "browserCompat",
        "summary",
        "popularity",
        "modified",
        "source",
        "short_title",
      ].map((key) => [key, node.data.metadata[key]]),
    );
    node.data.metadata.source = {
      folder: node.data.metadata.source.folder,
      last_commit_url: node.data.metadata.source.last_commit_url,
    };
    node.data.links = node.data.links.filter(
      (link) =>
        !link.startsWith("/en-US/") &&
        !link.startsWith("#") &&
        !link.includes("//localhost"),
    );
  }

  const commit = await $`git log -1 --format="%H %ct"`
    .cwd(Bun.fileURLToPath(import.meta.resolve(CONTENT_SOURCE_ROOT)))
    .text();

  await FS.writeFile("data/warnings.json", JSON.stringify(warnings, null, 2));
  await FS.writeFile("data/nodes.json", JSON.stringify(nodes, null, 2));
  await FS.writeFile("data/links.json", JSON.stringify(links, null, 2));
  await FS.writeFile(
    "data/last-update.json",
    JSON.stringify(
      {
        commitHash: commit.split(" ")[0],
        commitTimestamp: parseInt(commit.split(" ")[1]) * 1000,
        buildTimestamp: Date.now(),
      },
      null,
      2,
    ),
  );
  await FS.writeFile(
    "data/codes.json",
    JSON.stringify(Object.fromEntries(pageToCodes), null, 2),
  );
}
